# Claude Code Configuration Expertise
# Target: 400-500 lines | Domain: Operational knowledge for .claude/ configuration

overview:
  description: |
    Claude Code configuration—.claude/ directory structure, command patterns,
    hook implementation, expert 4-agent pattern (expertise.yaml + 4 agents),
    and slash command conventions. This expertise enables correct configuration
    of Claude Code projects.
  scope: |
    Covers .claude/ directory organization (agents/, commands/, hooks/, skills/,
    .cache/, data/), command frontmatter schema, hook types with uv, expert
    4-agent pattern (plan/build/improve/question in agents/experts/<domain>/),
    settings configuration, and naming conventions.

    ARCHITECTURAL NOTE [2025-12-26]: Skills are workflow templates (not agents)
    in .claude/skills/. Flat orchestration - /do directly spawns expert agents.
    Coordinators deprecated (nested subagent limitation). Does NOT cover agent
    prompt content (see agent-authoring expert).
  rationale: |
    Correct .claude/ configuration enables tooling, discoverability, and
    maintainability. Poor structure creates fragmentation and breaks tooling.

core_implementation:
  directory_structure:
    .claude/:
      agents/:
        purpose: Agent definitions (general-purpose + experts/)
        experts/<domain>/:
          purpose: 4-agent pattern (plan/build/improve/question + expertise.yaml)
          pattern: 12 domains × 4 agents = 48 agents total
      commands/:
        purpose: Slash commands by category
        do.md: Universal orchestrator - directly spawns expert agents
      skills/:
        purpose: Workflow templates (NOT agents) - guide /do orchestration
      hooks/:
        purpose: Lifecycle hooks (Python with uv)
        utils/: Hook utility modules
      .cache/:
        purpose: Gitignored ephemeral data
        specs/: Spec files from plan agents
        orchestration-traces.jsonl: Task execution traces
      data/:
        purpose: Session and state data (gitignored)
        sessions/: Session metadata JSON
        learnings/: Captured learnings
        temp/: Cross-hook coordination (timing markers)
      logs/:
        purpose: Session logs and analytics (gitignored)
      settings.json:
        purpose: Project-wide config (committed)
      settings.local.json:
        purpose: Local overrides (gitignored)

  key_files:
    - path: .claude/commands/<category>/<name>.md
      purpose: Slash command (frontmatter + prompt)
      invocation: /category:name
    - path: .claude/agents/experts/<domain>/<domain>-{plan,build,improve,question}-agent.md
      purpose: Expert 4-agent pattern with standardized colors
    - path: .claude/agents/experts/<domain>/expertise.yaml
      purpose: Structured domain knowledge (400-600 lines target, 1000 max)
    - path: .claude/hooks/<hook-name>.py
      purpose: Lifecycle hook with uv shebang
    - path: .claude/skills/<workflow>/SKILL.md
      purpose: Workflow template for /do orchestration
    - path: .claude/output-styles/<style-name>.md
      purpose: Reusable output formatting conventions

key_operations:
  create_slash_command:
    when: Adding new command functionality
    approach: |
      1. Create .claude/commands/<category>/<name>.md
      2. Add frontmatter:
         ---
         description: Brief command description (required)
         argument-hint: [param1] [param2 (optional)]
         allowed-tools: Tool, List, Here
         ---
      3. Write prompt (Purpose, Variables, Instructions, Workflow, Report)
      4. Invoked as /category:name
    examples:
      - .claude/commands/book/toc.md → /book:toc
      - .claude/commands/knowledge/capture.md → /knowledge:capture
    pitfalls:
      - what: "CRITICAL - Using colons in frontmatter string values"
        instead: "No colons in description, argument-hint, or any YAML value"
        reason: "Colons break YAML parsing in Claude Code's configuration system. Affects ALL frontmatter, not just agents. [2026-01-17]"

  create_command_with_orchestrator_agent:
    when: Command needs complex coordination beyond single agent capability
    pattern: DEPRECATED - Command + Orchestrator Agent Pairing NO LONGER WORKS
    architecture_issue: |
      CRITICAL CONSTRAINT [2026-02-02]:
      Subagents spawned via Task tool CANNOT use Task/TeammateTool to spawn nested agents.
      This breaks the "command delegates to orchestrator agent" pattern entirely.

      If orchestrator is a subagent, it cannot spawn teams. Architecture is fundamentally broken.
    correct_pattern: |
      For complex orchestration (especially TeammateTool):
      1. Create comprehensive slash command (.claude/commands/<category>/<name>.md)
         - Contains ALL orchestration logic (6 phases: init, classify, spawn, coordinate, wait, report)
         - Frontmatter: allowed-tools includes TeammateTool, SendMessage, Task, etc.
         - 500-700 lines typical for full swarm orchestration
         - No delegation to orchestrator agent (orchestration happens at command level)
      2. No separate orchestrator agent needed or wanted
      3. Update CLAUDE.md with command documentation
    examples:
      - .claude/commands/do.md - 600+ lines, orchestrates plan→build→improve directly
      - .claude/commands/do-swarm.md - 650+ lines, orchestrates swarm coordination directly
    rationale: |
      - TeammateTool operations MUST happen at command level
      - Delegation adds broken indirection layer (subagent can't spawn)
      - Single source of truth for orchestration logic
      - Mirrors Task tool constraint (same limitation)
    benefits:
      - Actually works (subagents can't spawn, commands can)
      - No broken delegation layer
      - Clear single source of truth
      - Comprehensive documentation in one file
    timestamp: "[2026-02-02] Pattern deprecated after discovering Task/TeammateTool spawning constraints"

  implement_hook:
    when: Need to run code on agent lifecycle events
    events: [SessionStart, UserPromptSubmit, PreToolUse, PostToolUse, SubagentStop, PreCompact, Stop]
    approach: |
      1. Create .claude/hooks/<hook-name>.py with uv shebang:
         #!/usr/bin/env -S uv run --script
         # /// script
         # requires-python = ">=3.8"
         # ///
      2. Implement hook function (read JSON from stdin)
      3. Exit 0 (allow) or 2 (block)
      4. Configure in .claude/settings.json hooks object
      5. Use matcher for tool-specific targeting (reduces overhead)
    examples:
      - pre_tool_use_logger.py: Log tool usage, security guards
      - orchestration_trace_logger.py: PostToolUse with Task matcher only

  create_expert_domain:
    when: Adding new expert domain with queryable expertise
    approach: |
      1. Create .claude/agents/experts/<domain>/
      2. Create expertise.yaml (overview, core_implementation, key_operations,
         decision_trees, patterns, best_practices, known_issues)
      3. Create <domain>-plan-agent.md (sonnet, yellow, Read/Glob/Grep/Write, output-style: academic-structured)
      4. Create <domain>-build-agent.md (sonnet, green, Read/Write/Edit/Glob/Grep, +Bash for ops, output-style: practitioner-focused)
      5. Create <domain>-improve-agent.md (sonnet, purple, all tools + Bash for git, output-style: evidence-grounded)
      6. Create <domain>-question-agent.md (haiku, cyan, Read/Glob/Grep only, output-style: concise-reference)
    pattern: 4-agent pattern replaces old 3-file triad (expertise + question + self-improve)
    examples:
      - curriculum: 12th domain, absorbed 2 standalone agents (888 lines total)
      - github: Absorbed github-versioning-agent (383 lines)
    pitfalls:
      - what: "CRITICAL - Using colons in agent description field (e.g., 'Expects: SPEC')"
        instead: "Remove colons from description values (use 'Expects SPEC' not 'Expects: SPEC')"
        reason: "Colons in YAML string values cause Claude Code's agent discovery parser to fail silently. Agents with colons in descriptions will NOT appear in /agents list. [2026-01-17] Root cause confirmed via systematic testing across 38 agents."

  configure_agent_output_style:
    when: Agent needs consistent output formatting
    approach: |
      1. Add output-style field to agent frontmatter (references .claude/output-styles/<name>.md)
      2. Add Output Style documentation to agent's Instructions section
      3. Use standard mappings for 4-agent expert pattern:
         - Question agents: concise-reference (scannable Q&A, haiku model)
         - Plan agents: academic-structured (rigorous specs, standard sections)
         - Build agents: practitioner-focused (action-first, code examples)
         - Improve agents: evidence-grounded (timestamped, git-backed claims)
    examples:
      - file: agents/experts/knowledge/knowledge-question-agent.md
        frontmatter: "output-style: concise-reference"
        instructions: "**Output Style:** Follow .claude/output-styles/concise-reference.md conventions"
    benefits:
      - Consistent output across similar agent types
      - Easier maintenance (update style file, all agents adapt)
      - Clear expectations for agent behavior
    timestamp: 2026-01-21

  configure_settings:
    when: Configuring permissions, hooks, or project behavior
    structure: |
      .claude/settings.json:
      {
        "statusLine": {"type": "command", "command": "..."},
        "permissions": {"allow": ["Read", "Glob"], "deny": []},
        "env": {"VAR": "value"},
        "hooks": {
          "<EventType>": [
            {
              "matcher": {"tool_name": "Task"},  // Optional: tool-specific
              "hooks": [{"type": "command", "command": "...", "timeout": 5000}]
            }
          ]
        }
      }
    notes: |
      - Local overrides in settings.local.json (gitignored)
      - Matcher enables tool-specific hooks (e.g., PostToolUse only for Task)
      - Valid JSON (no trailing commas)

decision_trees:
  command_vs_agent_vs_skill:
    question: What am I creating?
    options:
      - if: User-invoked task with fixed workflow
        then: Slash command (.claude/commands/)
      - if: Model-invoked sub-agent for delegation
        then: Agent (.claude/agents/)
      - if: Workflow template to guide /do orchestration
        then: Skill (.claude/skills/) - NOT an agent
      - if: Domain expertise with plan/build/improve/question
        then: Expert domain (.claude/agents/experts/<domain>/)
      - if: Command needs complex coordination (messaging, parallel, patterns)
        then: Command + Orchestrator Agent pair (do-swarm pattern)

  simple_vs_orchestrator_command:
    question: Is this a simple command or does it need orchestration?
    options:
      - if: Single sequential task, deterministic workflow
        then: Simple command (command file only)
        example: "/book:toc - regenerate table of contents"
      - if: Complex coordination, multi-pattern support, rich messaging
        then: Command + Orchestrator Agent pairing
        example: "/do-swarm - parallel coordination with leader-worker/council/pipeline patterns"
      - reasoning: |
          Orchestrator agents enable:
          - Multiple coordination patterns (lead-worker, council, pipeline)
          - Inter-agent messaging (Write/Broadcast)
          - Selective waiting strategies
          - Complex error handling per pattern
          - Future extensibility without command bloat

  expert_location:
    question: Where to put expert files?
    options:
      - file: Agent files (plan, build, improve, question)
        location: .claude/agents/experts/<domain>/
      - file: Expertise YAML
        location: .claude/agents/experts/<domain>/expertise.yaml
      - file: Spec files from plan agents
        location: .claude/.cache/specs/<domain>/

patterns:
  expert_domain_4agent:
    structure: |
      .claude/agents/experts/<domain>/
      ├── expertise.yaml (400-600 lines target, 1000 max)
      ├── <domain>-plan-agent.md (yellow, Read/Glob/Grep/Write, academic-structured output)
      ├── <domain>-build-agent.md (green, Read/Write/Edit/Glob/Grep, +Bash for ops, practitioner-focused output)
      ├── <domain>-improve-agent.md (purple, all + Bash for git analysis, evidence-grounded output)
      └── <domain>-question-agent.md (cyan, Read/Glob/Grep, haiku model, concise-reference output)
    color_coding:
      plan: yellow (analysis, planning)
      build: green (creation, implementation)
      improve: purple (review, expertise evolution)
      question: cyan (meta, read-only Q&A)
    output_style_defaults:
      plan: academic-structured (rigorous specs, standard sections)
      build: practitioner-focused (action-first, code examples)
      improve: evidence-grounded (timestamped learnings, git-backed claims)
      question: concise-reference (scannable Q&A, tables/bullets)
    trade_offs:
      pros: [Plan→build→improve lifecycle with approval gates, Color-coded roles, Consistent output styles, Expertise evolves via git analysis]
      cons: [5 files vs 3 (old pattern), More complexity than standalone agents]

  expertise_path_protocol:
    purpose: Pass domain expertise to spawned agents without context bloat
    pattern: |
      All agents spawned via TeammateTool receive EXPERTISE_PATH parameter:
      EXPERTISE_PATH=/absolute/path/to/.claude/agents/experts/{domain}/expertise.yaml

      Agents read this file at runtime to:
      - Understand domain conventions
      - Apply relevant patterns
      - Reference historical learnings
      - Access decision trees and best practices
    rationale: |
      Expertise.yaml files are 400-600 lines (sometimes 1000+). Embedding in
      spawned agent prompts causes context bloat and token waste. File path
      reference is more efficient: agents load only what they need for their task.

      Lead agents read full expertise.yaml. Worker agents read task-specific
      sections. Question agents reference for answering domain queries.
    implementation: |
      1. When spawning agent via TeammateTool, include in prompt:
         EXPERTISE_PATH: {absolute_path}
      2. Agent reads file early in execution
      3. Agent extracts relevant patterns for current task
      4. Worker agents: focus on sections matching subtask
      5. Lead agents: full context to coordinate workers
    scale_benefits:
      - Supports large expertise files (1000 lines)
      - Keeps spawned agent prompts compact
      - Expertise evolves independently (agents pick up changes on spawn)
      - Multiple workers read same file without duplication
    timestamp: "[2026-02-02] Discovered in /do-swarm orchestrator pattern"

  learning_separation_principle:
    purpose: Decouple swarm execution from expertise learning
    principle: |
      Swarm agents execute tasks. Improve agents learn from execution.
      These phases are separate and asynchronous.

      Execution Phase (live swarm):
      - Focus: Task execution only
      - Agents: Lead + workers perform work
      - Output: Files modified, results generated
      - No expertise updates

      Learning Phase (after swarm completes):
      - Focus: Extract patterns from execution
      - Agents: Domain improve-agent analyzes git history
      - Output: Expertise.yaml updates
      - User-triggered: /do "improve {domain} expertise"
    rationale: |
      Prevents race conditions: Multiple spawned agents cannot update expertise
      simultaneously. Keeps swarm execution focused and fast. Enables batch
      learning (analyze multiple swarm outputs together). Improves can fail
      without blocking successful execution.
    implementation: |
      1. Swarm execution via /do-swarm command
         Result: Files committed/modified, task complete
      2. User (or future: scheduled automation) runs:
         /do "improve {domain} expertise"
      3. Improve agent:
         - Analyzes recent git history
         - Extracts patterns from swarm outputs
         - Updates expertise.yaml
         - Documents learnings with timestamps
    workflow_diagram: |
      User: /do-swarm "complex task"
        ↓ swarm executes
      Result: Files modified, task complete
        ↓ separately:
      User: /do "improve {domain} expertise"
        ↓ improve agent analyzes git
      Result: Expertise.yaml updated with learnings
    trade_offs:
      pros: [No race conditions, Focused execution, Batch learning, Fail-safe]
      cons: [Extra step for user, Learning not automatic, Requires discipline]
    timestamp: "[2026-02-02] Pattern established in /do-swarm design"

  flat_orchestration_architecture:
    constraint: "Phase 1 enforces flat architecture—no nested sub-swarms"
    reason: |
      Unknown whether TeammateTool supports nested spawning (spawning agents
      that themselves spawn teams). Flat architecture is safer, faster, and
      simpler to reason about.
    implementation: |
      /do-swarm orchestrator spawns lead + workers (all flat).
      Workers do not spawn sub-teams.
      If nesting needed: orchestrator manually spawns agents sequentially.
    future_enhancement: |
      Once nested spawning is validated, can support:
      - Pipeline pattern (sequential handoffs)
      - Hierarchical coordination (manager agents spawn sub-teams)
      - Tree-based decomposition (hierarchical task breakdown)
    timestamp: "[2026-02-02] Constraint documented in do-swarm.md (orchestration moved to command level)"

  skill_as_workflow_template:
    structure: |
      .claude/skills/<workflow>/SKILL.md (NO agent frontmatter)
      ---
      name: workflow-name
      description: Use when... Triggers on "keyword".
      ---
      # Workflow steps as documentation
    purpose: Guide /do orchestration (not executable agent)
    trade_offs:
      pros: [Eliminates nested subagent limitation, Easier to maintain than agent code]
      cons: [No programmatic workflow enforcement, /do centralized complexity]

  hook_coordination_via_temp_files:
    use_case: PreToolUse and PostToolUse need to share state (e.g., timing)
    pattern: |
      PreToolUse writes → PostToolUse reads → cleanup
      - .claude/data/temp/<session-id>-task-timing.txt
      - PostToolUse unlink() after read
    examples:
      - pre_tool_use_logger.py writes timing marker
      - orchestration_trace_logger.py reads, calculates latency, deletes file

  orchestration_observability:
    purpose: Capture Task tool invocations for meta-improvement
    implementation: |
      1. PostToolUse hook with Task matcher in settings.json
      2. Extract metadata (agent name, phase, domain, workflow_type)
      3. Calculate latency (via PreToolUse coordination)
      4. Append to .claude/.cache/orchestration-traces.jsonl
    trace_schema:
      timestamp: ISO 8601
      session_id: UUID
      agent_name: e.g., knowledge-build-agent
      phase: [plan, build, improve, question]
      domain: [knowledge, github, curriculum, ...]
      workflow_type: expert
      latency_ms: integer
      success: boolean
      total_tokens: integer

  coordinate_multi_agent_execution:
    when: Multiple agents need to execute with coordination/messaging vs simple delegation
    tool_selection: |
      Task tool (existing, sequential):
      - Sequential delegation (plan→build→approve→improve)
      - Simple spawn-and-wait model
      - No inter-agent messaging
      - /do command uses Task for expert delegation

      TeammateTool (new, parallel):
      - Parallel execution with messaging
      - Inter-agent communication (Write/Broadcast)
      - Selective waiting (join specific agents, not all)
      - Coordination patterns: lead-worker, council, pipeline
      - /do-swarm command uses TeammateTool
    decision_criteria:
      - If agents work independently → Task (sequential)
      - If agents need messaging → TeammateTool (parallel)
      - If order matters → Task
      - If timing is flexible → TeammateTool
      - If one agent coordinates others → either (Task simpler if no messaging)
    implementation_patterns:
      lead_worker:
        use_when: One coordinator, N focused workers
        spawn: Lead agent + N worker agents
        coordination: Lead broadcasts work, workers write results to lead
        wait_strategy: Join lead only (workers may continue async)
      council:
        use_when: Multiple experts, equal standing, no single coordinator
        spawn: N expert agents (all equal)
        coordination: Orchestrator broadcasts question, experts write findings
        wait_strategy: Join all experts
      pipeline:
        use_when: Sequential with handoffs (future enhancement)
        spawn: Agents in sequence
        coordination: Agent N writes to Agent N+1
        wait_strategy: Join final agent
    timestamp: "[2026-02-02] Pattern extracted from /do-swarm implementation"

best_practices:
  organization:
    - Agents in .claude/agents/, commands in .claude/commands/
    - Expert domains: agents/experts/<domain>/ (4-agent + expertise.yaml)
    - Orchestrator agents: .claude/agents/<name>-orchestrator-agent.md (paired with command)
    - Skills: .claude/skills/ as workflow templates (NOT agents)
    - Specs: .claude/.cache/specs/ (gitignored ephemeral)
    - Expertise.yaml: 400-600 lines target, 1000 hard limit
    - Output styles: .claude/output-styles/ as reusable formatting conventions

  commands:
    - Naming: category:command pattern (/book:toc)
    - Frontmatter: description (required), argument-hint, allowed-tools
    - Use allowed-tools to restrict capabilities per command
    - CRITICAL: Never use colons in frontmatter string values (breaks YAML parsing)
    - For complex workflows: pair command with orchestrator agent (not 4-agent pattern)

  orchestrator_agents:
    - DEPRECATED PATTERN: Originally designed separate orchestrator agents for multi-pattern coordination
    - ARCHITECTURE CHANGE [2026-02-02]: Orchestration must happen at command level, not in subagents
    - Reason: Subagents spawned via Task tool cannot use Task/TeammateTool to spawn nested agents
    - New pattern: Command file contains ALL orchestration logic (see /do and /do-swarm as examples)
    - Supports multiple coordination patterns (lead-worker, council, pipeline)
    - Use TeammateTool for parallel coordination with messaging
    - Do NOT include improve phase (learning handled separately per learning_separation_principle)
    - Pass EXPERTISE_PATH to spawned agents (expertise_path_protocol pattern)

  expert_domains:
    - Standardized color coding (yellow/green/purple/cyan)
    - Standardized output styles (concise-reference/academic-structured/practitioner-focused/evidence-grounded)
    - Question agents: haiku model, read-only tools, concise-reference output
    - Plan agents: academic-structured output for rigorous specs
    - Build agents: practitioner-focused output for action-first guidance
    - Improve agents: Bash for git history analysis, evidence-grounded output with timestamps
    - Absorb standalone agents >300 lines into expert domains
    - CRITICAL: Never use colons in description field (breaks agent discovery)

  coordination:
    - Use Task tool for sequential delegation (plan→build→improve)
    - Use TeammateTool for parallel coordination with messaging
    - Pass expertise via EXPERTISE_PATH (file reference, not embedding)
    - Implement learning_separation_principle: execution and improvement are separate phases
    - For swarms: orchestrator spawns all agents flat (no nesting Phase 1)
    - Document coordination pattern (lead-worker, council, pipeline) in orchestrator

  swarm_operational_practices:
    - Shutdown ceremony is optional: quick research swarms can skip explicit shutdown (5min timeout saves 3-4 turns)
    - Full shutdown ceremony for production swarms: SendMessage with request/shutdown subtype, wait for approval
    - Instruct teammates to send plain-text results only (suppress JSON status messages in prompts)
    - Idle notifications are JSON and system-generated: ignore them, wait for plain-text results
    - Expected timing: spawn to first result ~30s, all parallel results ~1-2min, shutdown ceremony ~30s overhead
    - No progress visibility: instruct teammates to send interim updates if long-running tasks
    - Validation levels in worker prompts: Level 1 (syntax only), Level 2 (tests + types), Level 3 (full suite + manual)
    - Forbidden patterns: negative constraints, meta-commentary, vague instructions, unbounded scope
    - Role-based tool access: specify allowed tools explicitly to prevent confusion
    - timestamp: "[2026-02-02] Tactical patterns from initial /do-swarm usage and refinement (commit 75a4962)"

  hooks:
    - uv shebang for Python dependencies
    - Configure in settings.json by event type
    - Exit 0 (allow), 2 (block)
    - Matcher for tool-specific hooks (reduces overhead)
    - Temp files in .claude/data/temp/ for cross-hook coordination
    - Cleanup temp files after read (unlink)

  settings:
    - settings.json: project-wide (committed)
    - settings.local.json: local overrides (gitignored)
    - Valid JSON (no trailing commas)

  observability:
    - JSONL for append-only trace logs
    - Extract structured metadata from agent names
    - Store traces in .claude/.cache/ (gitignored)

known_issues:
  - issue: No automated validation of command frontmatter
    workaround: Manual review during command creation
    status: open

  - issue: Spec files in .claude/.cache/specs/ accumulate
    workaround: Manual cleanup (gitignored, non-critical)
    status: open

  - issue: Hook errors not always visible
    workaround: Explicit logging in hooks
    status: open

  - issue: Colons in frontmatter string values break YAML parsing
    impact: Agents/commands with colons in description field fail discovery silently
    resolution: |
      Fix b6a2b47 removed colons from 38 agent descriptions across 12 domains.
      Pattern changed from 'Expects: SPEC' to 'Expects SPEC'.
      Root cause: Claude Code YAML parser treats unquoted colons as key-value separators.
    prevention: Lint rule or validation check needed
    status: resolved [2026-01-17]

  - issue: Nested subagent limitation (coordinators couldn't spawn experts)
    resolution: Flat orchestration - /do directly spawns expert agents (commit 353d576)
    status: resolved

  - issue: Old 3-file expert pattern mixed location concerns
    resolution: 4-agent pattern in agents/experts/ (all 12 domains migrated)
    status: resolved

potential_enhancements:
  - Automated frontmatter validation for commands (low effort)
  - Command discovery interface - list all commands (low effort)
  - Spec file cleanup automation (low effort)
  - Hook debugging mode for visible errors (medium effort)
  - Orchestration trace aggregation tool for latency stats (low effort)
  - Temp file orphan cleanup on SessionStart (low effort)
  - Research nested TeammateTool spawning (medium effort, unblocks pipeline and hierarchical patterns)
  - Orchestrator agent templates for lead-worker, council, pipeline patterns (low effort, tooling)
  - Swarm execution visualization (medium effort, observability enhancement)
  - EXPERTISE_PATH hot-loading for multi-domain swarms (low effort, optional optimization)

stability:
  convergence_indicators:
    insight_rate_trend: decreasing
    contradiction_count: 0
    new_patterns_added_this_cycle: 0
    patterns_updated_this_cycle: 1
    decision_trees_added_this_cycle: 0
    last_reviewed: 2026-02-02
    utility_ratio: 1.0
    notes: |
      Cycle 2026-02-02b (second improve): Tactical refinements from initial /do-swarm usage.

      Updated Sections:
      1. best_practices.swarm_operational_practices - Added 10 operational patterns from fix commit 75a4962

      Tactical Patterns Added:
      - Optional shutdown ceremony (skip for quick swarms, save 3-4 turns)
      - JSON notification suppression (instruct teammates to send plain-text only)
      - Timing expectations (spawn ~30s, parallel results ~1-2min, shutdown ~30s)
      - No progress visibility workaround (interim updates for long tasks)
      - Validation level specification (L1/L2/L3 for worker prompts)
      - Forbidden patterns in teammate prompts (negative constraints, meta-commentary)
      - Role-based tool access enforcement (explicit allowed tools)

      Pattern Significance:
      These are convergence patterns—initial /do-swarm design (a1d5942) refined through
      real usage (75a4962 fix). Tactical guidance for practical swarm orchestration.

      File health: 597 lines (was 585), +12 lines for tactical patterns.
      Still well below 900 warning threshold (303 lines of headroom).

      Domain stability: High. This cycle adds operational refinements to existing swarm
      architecture. No contradictions. Insight rate decreasing (0 foundational patterns,
      1 tactical update). Suggests domain reaching maturity for swarm coordination.

      Previous Cycle (2026-02-02a): Major architectural pattern—command + orchestrator pairing,
      TeammateTool coordination, expertise path protocol, learning separation, flat orchestration
      constraint. Added 5 foundational patterns (+195 lines from 362 to 557).
